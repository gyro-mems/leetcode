# String to Integer (atoi)
This repository contains code of a solution to the atoi medium leetcode problem.

# Algorithm
This algorithm takes an input string and turns it into a number in a similar manner to the C/C++ function atoi. There are four important values that are used in the algorithm. The first is ***len*** which contains the length of the input string. The second is ***sign*** which will be set to 1 or -1 depending on whether a '+' or a '-' is read. It is set to 1 to indicate a positive number should be output, and it is set to -1 to indicate a negative number should be output. It is set to 1 as a default because any number without a sign in front of it is assumed to be positive. The third value is ***total*** which contains the value of what the currently read numerical characters in the string would be equal to as an integer. the fourth value is ***i*** which is an index that is used to look through the input string.  

This algorithm breaks up the problem into three distinct phases. The first phase removes the blank spaces from the beginning of the input string. This phase will end when the first non-blank space appears in the input string. The second phase checks if there is an indication that the output number should be negative or positive with the '-' or '+' characters. The third phase goes through the remaining characters in the string until the numerical characters read give a number that is outside the range of an integer, or a non-numerical character is read. These phases give a general overview of the code structure, but within each phase there are some important details that are required to ensure a correct output.

Within the first phase, the index integer ***i*** is used to check through the string while the current index in the string is blank. It starts at 0 because the first index in arrays in C++ is 0 (ex. str[0]). In the while loop check, besides checking if the current character in the string is blank, it also checks if the index is less than ***len*** or the length of the input string. This check ensures that the index does not access something that is not inside of the string. (This can be seen by drawing out small arrays and labeling them starting at 0. An array of size 3 will end at the only integer less than 3, 2.) Inside of the loop the index will be increased by one each time until one of the checks of the while loop fails. If the check that failed was the index check, then the index is greater than or equal to the length of the string (***len***) which means that the default ***total*** of 0 should be returned. If the check that failed was the blank character check, then the index will be the first place in the string that is not a blank character.  

Within the second phase, the first non-blank character is checked to see if it is '-' or '+'. If it is '-', ***sign*** is set to -1 to indicate the number should be negative, and then the index is increased by one. If it is '+', ***sign*** is set to 1 to indicate the number should be positive, and then the index is increased by one. This phase results in knowing the correct sign for the output and the index being at the correct character to read from for the next phase even if the character read in the second phase was not '-' or '+'. This is because if the character is not '-' or '+', nothing happens to the index and the default ***sign*** is 1 (indicating a positive number). So in the case of a '-' or '+', the sign is set and the next index is looked at, and in the case of a character that is not a '-' or '+', the index remains the same to look at the same character in the next phase.

The third phase is the most important part and uses more advanced concepts than the other phases. The first concept is that the input string stores the characters in ascii which means that the numerical characters, if treated as integers, are the stored as the values 48 to 57 with 48 being '0' and 57 being '9'. This means that if a character is between 48 and 57 it is a numercial character. The second concept is that subtracting 48 from the value of an numerical ascii character will bring the values to what they represent as an integer. For example, the value of '0' is 48 and subracting 48 gives 0. The third concept is that multiplying the current ***total*** by 10 and then adding or subtracting the integer an ascii character represents will build up the integer. For example, if the input string is '137', the first character read is '1' and the current total is 0. Multiplying the total by 10 gives 0 and adding 1 makes the total 1. Multiplying the total by 10 gives 10 and adding 3 makes the total 13. Multiplying the total by 10 gives 130 and adding 7 makes the total 137. This also works for negative numbers, but instead of adding, the second step subtracts. The fourth concept is that dividing one number by another gives the amount of times the second number can be multiplied by before it becomes larger than the first number. For example, 100 divided by 10 gives 10. This means that the number 10 can be multiplied by at most 10 times to not exceed 100. This might seem obvious, but it it important for avoiding integer overflows when multiplying the ***total*** by 10. The fifth concept is that when adding *x* and *y*, the combined value will not exceed *z* if *z*-*y* >= *x*. (This can be found through simple algebra. *Z* should be greater than or equal to *x* + *y*, in mathematical notation: *z*>= *x* + *y*). Subtracting y from both sides gives *z*-*y* >= *x*.)

# Runtime Complexity Analysis
This atoi algorithm does a constant number of operations for each character looked at in the input string. When it removes blank spaces from the input string, the only operation it does is increase the index to look at the next character in the string. The string will either be entirely made up of blank spaces which would be a runtime complexity of O(n), or it will find a character that is not a blank space and leave the rest of the characters to be looked at by the rest of the algorithm. The sign would then be checked which is a constant number of operations. Then the algorithm would then check the remaining characters until a non-numeric character was found or at most 11 numeric characters were used in a row. So once numbers are found in the string, at most 11 characters with a constant number of operations for each character will be searched (assuming that zeros don't precede the actual number). This means the part of the program that reads the actual number in the input string is an O(1) operation as the size of the string can grow arbitrarily large, but the amount of operations in this part remains the same. However, since big O notation takes into account the worst-case runtime, the runtime complexity of the algorithm is O(n). This is because the worst case is that all the characters are blank spaces and the algorithm has to go through the entire length of the input string. 

# Space Complexity Analysis
This atoi algorithm allocates space for 6 integers at most. This is independent of the size of the input which means the complexity of the extra space used is constant meaning it is O(1). However, the input string itself also must be stored so that it can be accessed by the algorithm. The space used by the string increases with its size giving it a space complexity of O(n). A space complexity of O(n+6) reduces to O(n) as it is the highest order term and will grow faster than the constant as the input size grows. Thus, the space complexity of this algorithm is O(n).   
